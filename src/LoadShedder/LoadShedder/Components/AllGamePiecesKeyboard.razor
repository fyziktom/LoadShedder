@using Newtonsoft.Json;
@inject HttpClient Http
<Row Margin="Margin.Is2.FromTop">
    <Column>
        <Row Margin="Margin.Is1.FromTop">
            <Column Flex="Flex.JustifyContent.Center">
                <Heading Size="HeadingSize.Is4">Producers</Heading>
            </Column>
        </Row>
        
        <Row Margin="Margin.Is1.FromTop">
            <Column Flex="Flex.AlignSelf.Center">
                @foreach(var gamepiece in Sources)
                {
                    @if (gamepiece.EnergyValue != 0)
                    {
                        @if (!gamepiece.IsPlugged)
                        {
                            <Button Clicked="@(() => PlacePiece(gamepiece.ExpectedVoltage.ToString()))" 
                            Color="Color.Primary" 
                            Style="width:230px"
                            Margin="Margin.Is1.FromStart.Is1.FromEnd.Is1.FromTop.Is1.FromBottom">
                                <Icon Name="IconName.BatteryFull" Margin="Margin.Is2.FromEnd" />
                                <small>Plug @gamepiece.Name - @(
                        gamepiece.EnergyValue / 1000
                        ) MW</small>  
                            </Button>
                        }
                        else
                        {
                            <Button Clicked="@(() => RemovePiece(gamepiece.ExpectedVoltage.ToString()))"
                            Color="Color.Secondary"
                            Style="width:230px"
                            Margin="Margin.Is1.FromStart.Is1.FromEnd.Is1.FromTop.Is1.FromBottom">
                                <Icon Name="IconName.BatteryFull" Margin="Margin.Is2.FromEnd" />
                                <small>Unplug @gamepiece.Name - @(
                        gamepiece.EnergyValue / 1000
                        ) MW</small>
                            </Button>
                        }
                    }
                }
            </Column>
        </Row>
    </Column>
    <Column>
        <Row Margin="Margin.Is1.FromTop">
            <Column Flex="Flex.JustifyContent.Center">
                <Heading Size="HeadingSize.Is4">Consumers</Heading>
            </Column>
        </Row>
        <Row Margin="Margin.Is1.FromTop">
            <Column>
                @foreach (var gamepiece in Consumers)
                {
                    @if (!gamepiece.IsPlugged)
                    {
                        <Button Clicked="@(() => PlacePiece(gamepiece.ExpectedVoltage.ToString()))"
                                Color="Color.Primary"
                                Style="width:230px"
                                Margin="Margin.Is1.FromStart.Is1.FromEnd.Is1.FromTop.Is1.FromBottom">
                                    <Icon Name="IconName.Hotel" Margin="Margin.Is2.FromEnd" />
                                    <small>Plug @gamepiece.Name - @(gamepiece.EnergyValue / 1000) MW</small>
                        </Button>
                    }
                    else
                    {
                        <Button Clicked="@(() => RemovePiece(gamepiece.ExpectedVoltage.ToString()))"
                                Color="Color.Secondary"
                                Style="width:230px"
                                Margin="Margin.Is1.FromStart.Is1.FromEnd.Is1.FromTop.Is1.FromBottom">
                                    <Icon Name="IconName.Hotel" Margin="Margin.Is2.FromEnd" />
                                    <small>Unplug @gamepiece.Name - @(gamepiece.EnergyValue / 1000) MW</small>
                        </Button>
                    }
                }
            </Column>
        </Row>
    </Column>
</Row>
@code {
    [Parameter]
    public EventCallback<string> OnBoardChanged { get; set; }
    [Parameter] public string DeviceId { get; set; } = "test";
    [Parameter] public string GameBoardId { get; set; } = "testBoard";

    public string ApiCommand { get; set; } = "/api/NewDeviceData";

    public int[] Board { get; set; } = new int[32];

    public List<GamePiece> Sources 
    {
        get => GamePieces.Values.Where(p => p.GamePieceType == GamePieceTypes.Source).ToList();
    }
    public List<GamePiece> Consumers
    {
        get => GamePieces.Values.Where(p => p.GamePieceType == GamePieceTypes.Consumer).ToList();
    }

    Dictionary<string, GamePiece> GamePieces = new Dictionary<string, GamePiece>();

    private Timer _timer;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await getGamePieces();
            _timer = new Timer(async (e) => { await PeriodicPost(); }, null, TimeSpan.Zero, TimeSpan.FromSeconds(1));
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    public async Task ClearKeyboard(string boardId, string deviceId)
    {
        if (!string.IsNullOrEmpty(boardId))
            GameBoardId = boardId;

        if (!string.IsNullOrEmpty(deviceId))
            DeviceId = deviceId;

        for (int i = 0; i < Board.Length; i++)
            Board[i] = 0;

        foreach(var gp in GamePieces.Values)
            gp.IsPlugged = false;

        await SendData();
        await InvokeAsync(StateHasChanged);
    }

    private async Task PeriodicPost()
    {
        try
        {
            await SendData();
        }
        catch(Exception ex)
        {
            Console.WriteLine("Cannot send periodic data: \n" + ex.Message);
        }
    }

    private async Task getGamePieces()
    {
        try
        {
            var result = await Http.GetFromJsonAsync<Dictionary<string, GamePiece>>("api/GetGamePieces");
            if (result != null)
                GamePieces = result;
        }
        catch (Exception ex)
        {
            Console.WriteLine("Cannot get GamePieces request response: \n" + ex.Message);
        }
        await InvokeAsync(StateHasChanged);
    }

    private async Task PlacePiece(string gamePieceId)
    {
        var index = -1;
        for(int i = 0; i < Board.Length; i++)
        {
            if (Board[i] == 0)
            {
                index = i;
                break;
            }
        }

        if (index >= 0)
        {
            if (GamePieces.TryGetValue(gamePieceId, out var gamePiece))
            {
                Board[index] = (int)gamePiece.GetGamePieceResistorVoltage();
                gamePiece.IsPlugged = true;
            }
            await ProcessRequest();
        }
    }

    private async Task RemovePiece(string gamePieceId)
    {
        var index = -1;
        if (GamePieces.TryGetValue(gamePieceId, out var gamePiece))
        {
            for (int i = 0; i < Board.Length; i++)
            {
                if (Board[i] == (int)gamePiece.GetGamePieceResistorVoltage())
                {
                    index = i;
                    break;
                }
            }

            if (index >= 0)
            {
                Board[index] = 0;
                gamePiece.IsPlugged = false;
                await ProcessRequest();
            }
        }
    }

    private async Task ProcessRequest()
    {

        await SendData();
        await InvokeAsync(StateHasChanged);
        await OnBoardChanged.InvokeAsync("BoardChanged");
    }

    private async Task<string> SendData()
    {
        var obj = new
        {
            id = DeviceId,
            data = Board
        };

        var cnt = JsonConvert.SerializeObject(obj);

        using (var content = new StringContent(cnt, System.Text.Encoding.UTF8, "application/json"))
        {
            HttpResponseMessage result = await Http.PostAsync("/" + ApiCommand.TrimStart('/'), content);
            if (result.StatusCode == System.Net.HttpStatusCode.OK)
            {
                var returnStr = await result.Content.ReadAsStringAsync();

                if (returnStr != null)
                    return returnStr;
                else
                    return "ERROR:Cannot read return message.";
            }
        }

        return string.Empty;
    }
}
